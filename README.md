# SW_QA
---
## Подготовка
1. Cкачать проект ```git clone https://github.com/pcade/SW_QA.git ```
2. Перейти в проект ```cd SW_QA```
3. Создать виртуальное окружение ```python3 -m venv env```
4. Запустить виртуальное окружение ```source env/bin/activate```
5. Установить зависимости ```pip install -r requirements.txt```
## Задание 1
---
> Устройство работает по serial интерфейсу. Отвечает на такие команды, как: 
>   запрос GET_V, ответ – “V_12V”
>   запрос GET_A, ответ – “A_1A”
>   запрос GET_S, ответ – “S_DSA123”
> Необходимо написать класс для работы с устройством на Python.
> Написать простые автоматизированные кейсы, используя свой класс, на Python/PyTest.
> В случае необходимости доп. информации, использовать собственные гипотезы и допущения,
> с описанием в тестовом задании.
---
### Особенности
Исходя из текста задания можно определить, следующее:
 - Системное окружение не определенно (`Win, Linux`);
 - Тип подключения `serial` интерфейса не определён (`UART, RS-232, RS-485, USB + MOXA`);
 - Отсутсвие данных о кодировке (`ASCII, UTF-8`);
 - Устройство не определенно;
 - Корректные данные о подключение не определены(`baud rate, data bits, stop bits, parity, timeout`)
 - Устройство подключено и настроенно в системе;
 - `serial` порт отвечает на команды **GET_V, GET_A, GET_S** с предопределенной логикой:
   - **GET_V** - ожидаемый результат `V_12V`, где:
     - **V_** - константа;
     - **12** - числовое значение без разделителя представленное (``Динамически | str``);
     - **V**  - константа (`Вольт`);
   - **GET_A** - ожидаемый результат `A_1A`, где:
     - **A_** - константа;
     - **1** - числовое значение без разделителя представленное (``Динамически | str``);
     - **A**  - константа (`Ампер`);
   - **GET_S** - ожидаемый результат `S_DSA123`, где:
     - **S_** - константа;
     - **DSA123** - нумерация серии представленная (``Динамически | str``).

> Учитывая всё выше изложенное необходимо учесть неопределенность
> технологического стека и способы взаимодействия с `serial` портом. Фактической
> зоной ответственности класса будет являться кроссплатформенное исполнение команд **GET_V, GET_A, GET_S** в оболочке python.

### Пример использования
```python3
from src.device_controller import DeviceController
with DeviceController(port='/dev/ttyUSB0',
                      baudrate=9600,
                      timeout=1.0) as device:
    try:
        # Получение напряжения
        voltage = device.get_voltage()
        print(f"Напряжение: {voltage}")
        
        # Получение тока
        ampere = device.get_ampere()
        print(f"Ток: {ampere}")
        
        # Получение серийного номера
        serial_num = device.get_serial()
        print(f"Серийный номер: {serial_num}")
        
    except Exception as e:
        print(f"Ошибка: {e}")
```
### Доступные тесты. 
#### Интеграционные тесты (`test_device_controller_integration.py`)
> Требуется наличие физического `serial` и подключенного, исправного устройства 
```bash
pytest tests/device_controller/integration -v
```

- Установка соединения с serial портом

- Соответствие измерения напряжения **GET_V**

- Соответствие измерения тока **GET_A**

- Соответствие серийного номера **GET_S**

- Последовательные операции

- Обработка ошибок

#### Unit тесты (`test_device_controller.py`)
```bash
pytest tests/device_controller/unit -v
```

- Валидация форматов напряжения **GET_V**

- Валидация форматов тока **GET_A**

- Валидации ответов на команду **GET_S**:

- Общий метод отправки команд

- Обработка специальных символов

- Обработка ошибки соединения


---
## Задание 2
---
>UDP server отвечает  на такие команды, как:
>   запрос {‘cmd’: ‘GET_V’}, ответ - {‘cmd’: ‘GET_V’, ‘payload’: ‘V_12V‘}
>   запрос {‘cmd’: ‘GET_ A’}, ответ - {‘cmd’: ‘GET_ A’, ‘payload’: ‘A_1A‘}
>   запрос {‘cmd’: ‘GET_ S’}, ответ - {‘cmd’: ‘GET_ S’, ‘payload’: ‘S_DSA123‘}
> Необходимо написать класс – клиент, используя  websocket + Python. 
> Написать простые автоматизированные кейсы, используя свой класс, на Python/PyTest.
> В случае необходимости доп. информации, использовать собственные гипотезы и допущения,
> с описанием в тестовом задании.
---
### Особенности
Исходя из текста задания можно определить, следующее:
 - Системное окружение не определенно (`Win, Linux`);
 - Данные о сервер отсутствуют (`IP, port`);
 - `Аутентификация и шифрование` не определено;
 - Тип подключения `Websocket`;
 - Протокол связи `TCP`;
 - Формат данных `JSON`;
 - Принято считать, что сервер отвечает на следующие обращения;
   - **GET_V**:
     -  `запрос` {'cmd': 'GET_V'}
     -  `ответ`  {'cmd': 'GET_V', 'payload': 'V_12V'}:
        - **payload** - константа;
        - **V_**      - константа;
        - **12**      - числовое значение без разделителя представленное (``Динамически | str``);
        - **V**       - константа (`Вольт`);
   - **GET_A**:
     -  `запрос` {'cmd': 'GET_A'}
     -  `ответ`  {'cmd': 'GET_A', 'payload': 'V_12V'}:
        - **payload** - константа;
        - **A_**      - константа;
        - **1**       - числовое значение без разделителя представленное (``Динамически | str``);
        - **A**       - константа (`Ампер`);
   - **GET_S**:
     -  `запрос` {'cmd': 'GET_S'}
     -  `ответ`  {'cmd': 'GET_S', 'payload': 'S_DSA123'}:
        - **payload** - константа;
        - **S_**      - константа;
        - **DSA123**  - нумерация серии представленная (``Динамически | str``).

### Пример использования
```python3
from src.websocket_client import WebsocketClient

# Пример 1: Использование с контекстным менеджером
with WebsocketClient("ws://localhost:8765") as client:
    voltage = client.get_voltage()
    ampere = client.get_ampere()
    serial = client.get_serial()
    
    print(f"Напряжение: {voltage}")
    print(f"Ток: {ampere}")
    print(f"Серийный номер: {serial}")

# Пример 2: Явное управление
client = WebsocketClient("ws://192.168.1.100:8080")
try:
    voltage = client.get_voltage()
    print(f"Напряжение: {voltage}")
finally:
    client.close()
```
### Доступные тесты.
#### Интеграционные тесты (`test_websocket_client_integration.py`)
> Требуется наличие работающего `UDP` сервера, с открытым `TCP` портом, отдающим корректные данные 
```bash
pytest tests/websocket_client/integration -v
```

- Установка соединения с сервером портом

- Соответствие измерения напряжения **GET_V**

- Соответствие измерения тока **GET_A**

- Соответствие серийного номера **GET_S**

- Последовательные операции

- Обработка ошибок

- Тест контекстного менеджера

- Тест переподключения

#### Unit тесты (`test_device_controller.py`)
```bash
pytest tests/websocket_client/unit -v
```

- Валидация форматов напряжения **GET_V**

- Валидация форматов тока **GET_A**

- Валидации ответов на команду **GET_S**:

- Общий метод отправки команд

- Обработка ошибки соединения